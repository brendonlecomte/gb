#include "ppu.h"
#include "CPU.h"
#include "memory.h"
#include "memory_locations.h"
#include "debug.h"
#include "lcd.h"

uint8_t plus_tile[16] = {0xFF, 0xFF,
                        0xFF, 0xFF,
                        0xFF, 0xFF,
                        0xFF, 0xFF,
                        0xFF, 0xFF,
                        0xFF, 0xFF,
                        0xFF, 0xFF,
                        0xFF, 0xFF,};
uint8_t white_tile[16] = { 0x00 };

uint8_t fake_palette[4] = {0x00, 0x0F, 0xF0, 0xFF};
tile_t *fake_tiles[2] = {white_tile, plus_tile};
uint8_t fake_bg[1024] = {
0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00,
0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00,
0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00,
0x01, 0x00,

0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01,
0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01,
0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01,
0x00, 0x01,

0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00,
0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00,
0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00,
0x01, 0x00,

0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01,
0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01,
0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01,
0x00, 0x01,

0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00,
0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00,
0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00,
0x01, 0x00,

0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01,
0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01,
0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01,
0x00, 0x01,

0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00,
0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00,
0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00,
0x01, 0x00,

0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01,
0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01,
0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01,
0x00, 0x01,

0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00,
0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00,
0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00,
0x01, 0x00,

0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01,
0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01,
0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01,
0x00, 0x01,

0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00,
0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00,
0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00,
0x01, 0x00,

0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01,
0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01,
0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01,
0x00, 0x01};


uint8_t background[0xFFFF] = {0x00};

void draw_line(uint8_t line);

typedef enum {
    PPU_IDLE,
    PPU_OAM,
    PPU_TRANSFER,
    PPU_H_BLANK,
    PPU_V_BLANK
} ppu_mode_t;

lcd_status_register_t *status_reg;
uint8_t *lcd_y;
// uint16_t *sprites[10]; //max of 10 sprites per line
int_reg_t *interrupts;
uint8_t *tile_map = &fake_bg[0];
ppu_mode_t mode;
uint16_t clocks;

void ppu_init(void) {
    status_reg = (lcd_status_register_t*)&memory->memory[STAT];
    lcd_y = &memory->memory[LY];
    lcd_init();
}

uint8_t count =0;
void ppu_run(void) {
  clocks += 1;

  switch(mode)
  {
    case PPU_OAM: //20 clocks
      status_reg->mode = 2;
      if(clocks >= 20) {
          mode = PPU_TRANSFER;
      }
      break;

    case PPU_TRANSFER: //43 clocks
      status_reg->mode = 3;
      if(clocks >= 63) {
          mode = PPU_H_BLANK;
      }
      break;

    case PPU_H_BLANK: //51 clocks
      status_reg->mode = 0;
      if(clocks >= 114){
        *lcd_y += 1; //line completed
        clocks = 0; //clear clocks, line complete
        if(*lcd_y == 144){
            CPU_set_interrupt(gb_cpu, INT_V_BLANK);
            mode = PPU_V_BLANK;
        }
        else {
            mode = PPU_OAM;
        }
      }
      break;

    case PPU_V_BLANK:
      status_reg->mode = 1;
      if(clocks >= 1254){
          clocks =0;
          *lcd_y = 0; //back to top of screen
          mode = PPU_OAM;
      }
      break;

    case PPU_IDLE: //there is no idle
    default:
      mode = PPU_OAM;
      break;
  }

  draw_line(count);
  lcd_refresh();
  count++;
}

void ppu_close(void) {

    lcd_close();
}

//BGP is palette

void draw_line(uint8_t line)
{
    uint8_t tile_row = line / 32; //get line of tile map
    // tile_t *tile = tile_map + tile_row; //get pointer to the first tile in the row
    uint8_t line_in_tile = line % 8;

    for(int i =0; i < 32; i++) //each tile
    {
        tile_t *t = fake_tiles[fake_bg[i]]; //tile_row + i];
        for(int j = 0; j < 8; j++) //each pixel in tile row
        {
            uint8_t colour, a, b, val;
            a = t->map[line];
            b = t->map[line+1];
            val = (a>>(7-j) &0x01)<<1 | (b>>(7-j) &0x01);
            colour = fake_palette[val];
            lcd_set_pixel((i*8)+j, line, colour);
        }
    }

}
